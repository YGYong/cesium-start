#### 基础

1. Transforms、Matrix4 介绍
2. 粒子系统、点云数据

#### 专业名词

1. 倾斜摄影，白膜数据，BIM 模型，LOD，剖面分析

#### 封装 hooks

1. 事件
2. 交互工具
3. 


#### 案例

- 视锥体
- 碰撞检测
- 聚合
- 实体悬浮高亮

```js
// 实体悬停效果实现
let highlightedEntity = null;
viewer.screenSpaceEventHandler.setInputAction((movement) => {
  const picked = viewer.scene.pick(movement.endPosition);

  // 清除上一个高亮实体
  if (highlightedEntity && (!picked || picked.id !== highlightedEntity)) {
    highlightedEntity.polygon.material = Cesium.Color.RED.withAlpha(0.5);
    highlightedEntity = null;
  }

  // 高亮当前实体
  if (picked && picked.id instanceof Cesium.Entity) {
    highlightedEntity = picked.id;
    highlightedEntity.polygon.material = Cesium.Color.YELLOW.withAlpha(0.7);
  }
}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
```

- 动态闪烁

heightReference 不能设置为 CLAMP_TO_GROUND 贴地显示

```js
const pointEntity = viewer.entities.add({
  position: Cesium.Cartesian3.fromDegrees(116.3975, 39.9075, 50),
  point: {
    color: Cesium.Color.RED.withAlpha(0.8), // 80% 不透明的红色
    pixelSize: 20, // 直径20像素
    outlineColor: Cesium.Color.WHITE, // 白色轮廓
    outlineWidth: 3, // 轮廓宽度3像素
    show: true, // 默认显示
  },
});
// 使用时间动态颜色实现闪烁
pointEntity.point.color = new Cesium.CallbackProperty(() => {
  const alpha = 0.5 + 0.5 * Math.sin(Date.now() / 500);
  return Cesium.Color.RED.withAlpha(alpha);
}, false);
```

- 将相机限制在某个区域（下面代码存在问题）

```js
// 限制相机在北京市范围内
const beijingBounds = Cesium.Rectangle.fromDegrees(115.7, 39.4, 117.4, 41.0);

viewer.camera.changed.addEventListener(() => {
  const cartographic = Cesium.Cartographic.fromCartesian(
    viewer.camera.position
  );

  // 检查是否超出边界
  if (!Cesium.Rectangle.contains(beijingBounds, cartographic)) {
    // 计算边界内最近点
    const clamped = Cesium.Rectangle.clamp(beijingBounds, cartographic);
    viewer.camera.position = Cesium.Cartesian3.fromRadians(
      clamped.longitude,
      clamped.latitude,
      clamped.height
    );
  }
});
```

- 绘制

- 实体拖拽交互

- 动态纹理材质

```javascript
entity.polygon.material = new Cesium.ImageMaterialProperty({
  image: "/textures/water.jpg",
  transparent: true,
  // 动态纹理偏移（实现流动效果）
  repeat: new Cesium.Cartesian2(2, 2),
  offset: new Cesium.CallbackProperty(() => {
    return new Cesium.Cartesian2(
      viewer.clock.currentTime.secondsOfDay / 10,
      0
    );
  }, false)
});
```

- 粒子系统材质

```javascript
// 创建粒子系统
const particleSystem = new Cesium.ParticleSystem({
  image: "/textures/particle.png",
  startColor: Cesium.Color.RED.withAlpha(0.8),
  endColor: Cesium.Color.YELLOW.withAlpha(0.0),
  startScale: 1.0,
  endScale: 4.0,
  particleLife: 2.0,
  speed: 5.0,
  emissionRate: 10,
  width: 50,
  height: 50,
  lifeTime: 16.0
});

// 应用为实体材质
entity.point.material = new Cesium.ParticleSystemMaterialProperty(particleSystem);
```

- 通过父子关系构建实体层级结构

```js
// 创建父实体
const parentEntity = viewer.entities.add({
  position: Cesium.Cartesian3.fromDegrees(116.3975, 39.9075),
  name: "校园",
});

// 创建子实体
const buildingEntity = viewer.entities.add({
  parent: parentEntity, // 设置父实体
  position: new Cesium.Cartesian3(100, 50, 0), // 相对父实体的局部坐标
  box: {
    dimensions: new Cesium.Cartesian3(80, 40, 60),
    material: Cesium.Color.GRAY,
  },
});

const roadEntity = viewer.entities.add({
  parent: parentEntity,
  polyline: {
    positions: [
      new Cesium.Cartesian3(-200, -100, 0),
      new Cesium.Cartesian3(200, 100, 0),
    ],
    width: 10,
    material: Cesium.Color.WHITE,
  },
});

// 操作父实体影响所有子实体
parentEntity.position = Cesium.Cartesian3.fromDegrees(116.4075, 39.9175);
```


#### 性能优化

- 数据分块加载，当处理成千上万的实体时，需要采用特殊策略优化性能

```javascript
// 实现数据分块加载
class EntityChunkLoader {
  constructor(viewer, chunkSize = 1000) {
    this.viewer = viewer;
    this.chunkSize = chunkSize;
    this.loadedChunks = new Set();
    this.dataSource = new Cesium.CustomDataSource("chunkedData");
    viewer.dataSources.add(this.dataSource);
    
    // 监听相机移动，动态加载数据块
    viewer.camera.moveEnd.addEventListener(() => this.loadVisibleChunks());
  }
  
  // 加载可见区域的数据块
  loadVisibleChunks() {
    const viewRectangle = viewer.camera.computeViewRectangle();
    const chunks = this.getChunksInView(viewRectangle);
    
    chunks.forEach(chunkId => {
      if (!this.loadedChunks.has(chunkId)) {
        this.loadChunk(chunkId);
        this.loadedChunks.add(chunkId);
      }
    });
  }
  
  // 加载单个数据块
  async loadChunk(chunkId) {
    const entities = await fetchEntitiesFromServer(chunkId);
    this.dataSource.entities.addMany(entities);
  }
}

// 使用分块加载器
const chunkLoader = new EntityChunkLoader(viewer);
chunkLoader.loadVisibleChunks();
```

- 对于大量相同类型的实体，使用`Primitive`配合`GeometryInstance`实现批处理渲染：

```javascript
// 创建实例化几何体
const instances = [];
for (let i = 0; i < 10000; i++) {
  // 随机位置
  const lon = 116.3975 + (Math.random() - 0.5) * 0.2;
  const lat = 39.9075 + (Math.random() - 0.5) * 0.2;
  
  instances.push(new Cesium.GeometryInstance({
    geometry: new Cesium.BoxGeometry({
      vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT,
      dimensions: new Cesium.Cartesian3(5, 5, 10)
    }),
    modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(
      Cesium.Cartesian3.fromDegrees(lon, lat)
    ),
    attributes: {
      color: Cesium.ColorGeometryInstanceAttribute.fromColor(
        Cesium.Color.fromRandom({ alpha: 0.7 })
      )
    },
    id: `building-${i}`
  }));
}

// 添加到场景
viewer.scene.primitives.add(new Cesium.Primitive({
  geometryInstances: instances,
  appearance: new Cesium.PerInstanceColorAppearance({
    translucent: true,
    closed: true
  }),
  asynchronous: true // 异步加载
}));
```

#### LOD（细节层次）控制

为不同距离范围提供不同精度的实体表示：

```javascript
// 实现LOD实体
function createLodEntity(viewer) {
  const entity = viewer.entities.add({
    position: Cesium.Cartesian3.fromDegrees(116.3975, 39.9075, 100),
    // 根据距离切换不同几何表示
    billboard: new Cesium.CallbackProperty(() => {
      const distance = Cesium.Cartesian3.distance(
        viewer.camera.position,
        entity.position.getValue(viewer.clock.currentTime)
      );
      
      if (distance > 5000) {
        return { image: "/icons/low_detail.png", scale: 0.8 };
      } else if (distance > 2000) {
        return { image: "/icons/medium_detail.png", scale: 1.0 };
      }
      return { image: "/icons/high_detail.png", scale: 1.2 };
    }, false),
    // 近距离显示详细模型
    model: new Cesium.CallbackProperty(() => {
      const distance = Cesium.Cartesian3.distance(
        viewer.camera.position,
        entity.position.getValue(viewer.clock.currentTime)
      );
      
      return distance < 1000 ? {
        uri: "/models/detail_model.glb",
        scale: 0.5
      } : undefined; // 距离远时不显示模型
    }, false)
  });
  return entity;
}
```


### 6.2 交互式编辑系统

实现实体的创建和编辑功能：

```javascript
class EntityEditor {
  constructor(viewer) {
    this.viewer = viewer;
    this.handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    this.isEditing = false;
    this.currentEntity = null;
    this.points = [];
    this.setupEvents();
  }
  
  // 设置事件监听
  setupEvents() {
    // 左键点击添加点
    this.handler.setInputAction((movement) => {
      if (!this.isEditing) return;
      
      const position = this.getClickPosition(movement.position);
      if (position) {
        this.points.push(position);
        this.updateCurrentEntity();
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    
    // 右键完成编辑
    this.handler.setInputAction(() => {
      if (this.isEditing && this.currentEntity) {
        this.isEditing = false;
        this.finalizeEntity();
      }
    }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
    
    // 鼠标移动更新临时实体
    this.handler.setInputAction((movement) => {
      if (this.isEditing && this.points.length > 0) {
        const position = this.getClickPosition(movement.position);
        if (position) {
          const tempPoints = [...this.points, position];
          this.updateTemporaryEntity(tempPoints);
        }
      }
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
  }
  
  // 获取点击位置
  getClickPosition(screenPosition) {
    const ray = this.viewer.camera.getPickRay(screenPosition);
    return this.viewer.scene.globe.pick(ray, this.viewer.scene);
  }
  
  // 开始创建实体
  startCreate(type) {
    this.isEditing = true;
    this.type = type;
    this.points = [];
    this.currentEntity = null;
    this.tempEntity = null;
  }
  
  // 更新当前实体
  updateCurrentEntity() {
    if (!this.currentEntity) {
      this.currentEntity = this.viewer.entities.add({
        [this.getTypeProperty()]: this.getGeometryProperty(this.points)
      });
    } else {
      this.currentEntity[this.getTypeProperty()] = this.getGeometryProperty(this.points);
    }
  }
  
  // 更新临时实体
  updateTemporaryEntity(points) {
    if (!this.tempEntity) {
      this.tempEntity = this.viewer.entities.add({
        [this.getTypeProperty()]: this.getGeometryProperty(points, true)
      });
    } else {
      this.tempEntity[this.getTypeProperty()] = this.getGeometryProperty(points, true);
    }
  }
  
  // 完成实体创建
  finalizeEntity() {
    // 移除临时实体
    if (this.tempEntity) {
      this.viewer.entities.remove(this.tempEntity);
      this.tempEntity = null;
    }
    
    // 添加实体到集合
    this.viewer.entities.add(this.currentEntity);
    
    // 触发创建完成事件
    this.onEntityCreated(this.currentEntity);
  }
  
  // 获取几何属性
  getGeometryProperty(points, isTemp = false) {
    const properties = {
      polyline: {
        positions: points,
        width: isTemp ? 2 : 3,
        material: isTemp ? Cesium.Color.YELLOW : Cesium.Color.BLUE
      },
      polygon: {
        hierarchy: points,
        material: isTemp ? Cesium.Color.YELLOW.withAlpha(0.3) : Cesium.Color.BLUE.withAlpha(0.5),
        outline: true,
        outlineColor: Cesium.Color.BLACK
      }
    };
    return properties[this.type];
  }
  
  // 获取类型属性名
  getTypeProperty() {
    return this.type === 'polyline' ? 'polyline' : 'polygon';
  }
  
  // 创建完成回调
  onEntityCreated(entity) {
    console.log('实体创建完成:', entity);
  }
}

// 使用编辑器
const editor = new EntityEditor(viewer);
// 开始创建多边形
editor.startCreate('polygon');
```



